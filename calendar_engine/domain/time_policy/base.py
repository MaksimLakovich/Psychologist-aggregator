from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import time, timedelta


@dataclass(frozen=True)
class TimeGridSlot:
    """Базовый слот доменной временной сетки:
        - это НЕ availability и НЕ booking.
        - это правила конкретного домена (например, "Психологи") о том, что для их клиентов в приложении является
          временным слотом по умолчанию.
        - frozen=True делает объект "замороженным/неизменяемым" - после создания нельзя поменять start/duration."""

    start: time  # Определение поля start. Это объект типа "время" (часы, минуты), указывающий начало слота
    duration: timedelta  # Определение поля duration. Это объект, представляющий длительность (разницу во времени)

    # Декоратор, который превращает метод в "свойство". Это позволяет обращаться к end как к переменной (slot.end),
    # а не как к функции (slot.end())
    @property
    def end(self) -> time:
        """Метод для вычисления времени окончания слота. Возвращает объект time."""
        # Расчет общего количества секунд от начала суток до конца слота.
        # Складываются секунды из часа старта, минут старта и длительности duration.
        total_seconds = (
            self.start.hour * 3600
            + self.start.minute * 60
            + int(self.duration.total_seconds())
        )
        # Функция divmod делит общее число секунд на 3600 (секунд в часе).
        # Hours - получает целое число часов, а Remainder - остаток в секундах.
        hours, remainder = divmod(total_seconds, 3600)
        # Остаток секунд делится на 60, чтобы получить количество минут.
        # Символ _ означает, что оставшиеся секунды нам не важны и мы их игнорируем.
        minutes, _ = divmod(remainder, 60)

        # Создается и возвращается новый объект time.
        # Оператор % 24 нужен, чтобы время "сбрасывалось" (например, если слот начинается в 23:00 и длится 2 часа,
        # то получится 01:00 вместо 25:00).
        return time(hour=hours % 24, minute=minutes)


"""
Главная проблема, которую решает этот код: в Python нельзя просто сложить time и timedelta.
Если мы напишем time(14, 0) + timedelta(minutes=30), то Python выдаст ошибку. Поэтому нам нужно перевести все
в секунды, складывать их, а потом превращать обратно в "человеческое" время.

1. Разбор формулы total_seconds на примере.
- Допустим, наш слот:
    Начало (start): 14:30
    Длительность (duration): 1 час 15 минут (или 4500 секунд)
- Считаем по формуле из кода:
    self.start.hour * 3600: Берем часы (14) и переводим в секунды (14 * 3600 = 50400 сек.)
    self.start.minute * 60: Берем минуты (30) и переводим в секунды (30 * 60 = 1800 сек.)
    int(self.duration.total_seconds()): Берем длительность в секундах (4500 сек.)
    Итого total_seconds: (50400 + 1800 + 4500 = 56700) секунд от начала суток
- Дальше нам нужно сделать обратную конвертацию, чтоб понять какое это "человеческое" время на часах будет:
    hours, remainder = divmod(56700, 3600) это:
       --- 56700 / 3600 = 15) целых часов.
       --- Остаток (remainder) = 2700 секунд.
    minutes, _ = divmod(2700, 60) это:
       --- 2700 / 60 = 45 полных минут.
       --- Остаток (секунды) нам не нужен.
    return time(hour=15 % 24, minute=45)
       --- Результат: 15:45.
    Это идеально совпадает: 14:30 + 1ч 15мин = 15:45.

Метод end позволяет не хранить время окончания в базе данных. Мы храним только "Во сколько начали" и "Сколько длится".
"""


class DomainTimePolicy(ABC):
    """Контракт доменной временной политики. Абстрактный класс описывает интерфейс или "чертеж" для будущих
    правил работы со временем (это называется "созданием контракта").
    Техническое пояснение: объявление абстрактного класса (Abstract Base Class) говорит Python, что нельзя
    создать объект этого класса напрямую (выдаст ошибку). Этот класс нужен только как "шаблон" для других классов."""

    # Декоратор, который помечает метод как "обязательный". Если создать дочерний класс и забыть написать там
    # метод slot_duration, то Python не позволит создать экземпляр этого класса.
    @abstractmethod
    def slot_duration(self) -> timedelta:
        """Метод, который возвращает базовую длительность слота домена (например, 60 минут).
        Самой логики здесь нет, только "заголовок"."""
        raise NotImplementedError

    @abstractmethod
    def generate_daily_grid(self) -> list[TimeGridSlot]:
        """Метод, который генерирует базовую временную сетку дня для домена (список всех доступных слотов):
            - с 08:00 до 21:00;
            - с 00:00 до 23:59;
            - и так далее, где каждый домен может устанавливать свою сетку.
        Возвращать он должен список объектов TimeGridSlot."""
        raise NotImplementedError
