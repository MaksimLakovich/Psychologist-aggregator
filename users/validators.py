from django.core.exceptions import ValidationError

from users.constants import MAX_AVAILABLE_FILE_SIZE

# from django.utils import timezone


def validate_file_size(value):
    """Кастомный валидатор для проверки максимально допустимого размера загружаемого файла."""
    limit = MAX_AVAILABLE_FILE_SIZE * 1024 * 1024  # MAX_AVAILABLE_FILE_SIZE например = 5 MB
    if value.size > limit:
        raise ValidationError(f"Максимальный размер файла - {MAX_AVAILABLE_FILE_SIZE} МБ.")


# class MaxYearWithOffsetValidator:
#     """Валидатор для проверки максимального допустимого года в числовых полях модели (например, year_end обучения).
#     -------------------------------------------
#     Основная идея:
#         1) Проверка, что значение года (например, 2028) не превышает "текущий год + допустимое смещение (offset)".
#         2) Это полезно, когда год указывается вручную, но должен оставаться реалистичным (например, "не позже чем
#         через 10 лет").
#     -------------------------------------------
#     Проблема, которую решает:
#         1) Нельзя просто написать validators=[timezone.now().year + 10] в самой модели Education,
#         потому что Django вычислит это выражение 1 раз при старте приложения или миграции,
#         а не при каждом создании объекта. Мы получим проблему - устаревания формулы 'timezone.now().year + 10'.
#         2) Этот класс (вне модели) делает проверку "динамической" - т.е. вычисляет текущий год при каждом вызове.
#     -------------------------------------------
#     Почему класс, а не функция:
#         1) Django умеет сериализовать только те объекты, которые реализуют метод deconstruct().
#         2) Без этого при создании миграций ORM выдаст ошибку вида:
#             "ValueError: Cannot serialize: <users.validators.MaxYearWithOffsetValidator object ...>"
#         3) Метод deconstruct() сообщает Django, как восстановить этот объект при миграции."""
#
#     def __init__(self, offset):
#         """Конструктор валидатора.
#         :param offset: Это допустимое смещение в годах относительно текущего года.
#         Например, offset=10 означает "год не может быть больше текущего + 10"."""
#         self.offset = offset
#
#     def __call__(self, value):
#         """Основной метод валидации. Вызывается автоматически Django при проверке поля модели.
#         :param value: Это значение, введенное пользователем (например, 2032).
#         :raises ValidationError: Если значение больше, чем (текущий_год + offset)."""
#         # Получаем текущий год каждый раз при создании нового объекта (на момент вызова, а не при миграции, как
#         # это бы было при добавлении такого валидатора прямо в модели, что привело бы к "устареванию" правила!)
#         current_year = timezone.now().year
#
#         # Рассчитываем максимально допустимое значение с учетом заданного в коде offset.
#         max_year = current_year + self.offset
#
#         # Проверяем превышение и выбрасываем исключение, если условие нарушено.
#         if value > max_year:
#             raise ValidationError(
#                 f"Год не может быть больше {max_year}. "
#                 f"Текущий год: {current_year}, заданное значение: {value}."
#             )
#
#     def __eq__(self, other):
#         """Метод сравнения двух экземпляров валидатора.
#         1) Django использует его, чтобы определить, изменился ли валидатор между миграциями.
#         2) Без этого метода Django будет сравнивать объекты по ссылке (т.е. id() в памяти) и в итоге каждый раз,
#         при запуске makemigrations, Django будет считать валидатор "новым объектом", т.е. ошибочно считать, что
#         объект валидатора изменился и генерировать ненужные миграции при каждом вызове makemigrations.
#         Т.е. миграции будут работать, но появится "шум" потому что makemigrations будет генерировать повторные
#         изменения без причины."""
#         return isinstance(other, self.__class__) and self.offset == other.offset
#
#     def deconstruct(self):
#         """Метод сериализации валидатора для системы миграций Django.
#         Возвращает кортеж из 3-х элементов:
#         1) Путь к классу валидатора (строкой)
#         2) Позиционные аргументы конструктора
#         3) Именованные аргументы конструктора (если есть)
#
#         Django использует это, чтобы записать валидатор в файл миграций и восстановить его при выполнении migrate.
#         Без deconstruct() Django не сможет сериализовать объект и выбросит ошибку:
#             "Cannot serialize: <MaxYearWithOffsetValidator ...>". """
#         return (
#             f"{self.__class__.__module__}.{self.__class__.__name__}",  # путь до класса
#             [self.offset],  # позиционные аргументы конструктора
#             {},  # именованных аргументов нет
#         )
